В C# (и не только в C#) часто делят задачи на два типа: **CPU-bound** и **I/O-bound**.

### 1. Что такое CPU-bound операции?

**CPU-bound** (CPU-ограниченные) — это задачи, которые в основном загружают **центральный процессор**.
То есть основное «узкое место» — это скорость выполнения вычислений самим CPU.

Примеры:

* Обработка больших массивов данных.
* Шифрование и хэширование.
* Генерация изображений или видео.
* Математические расчёты (например, работа с нейросетями).

**Особенности:**

* Здесь важна производительность процессора и количество его ядер.
* Асинхронность (`async/await`) обычно мало помогает, потому что операция не ждёт внешнего ресурса.
* Чтобы ускорить такие задачи, используют:

  * **Параллелизм** (`Parallel.For`, `Parallel LINQ (PLINQ)`).
  * Запуск на **пуле потоков** (`Task.Run(...)`).
  * Оптимизацию кода и алгоритмов.

Пример CPU-bound задачи:

```csharp
public int Calculate()
{
    int result = 0;
    for (int i = 0; i < 1_000_000_000; i++)
    {
        result += i % 3;
    }
    return result;
}
```

Здесь вся нагрузка — на процессор.

---

### 2. Что такое I/O-bound операции?

**I/O-bound** (ограниченные операциями ввода-вывода) — это задачи, где основное время уходит **на ожидание внешних ресурсов**, а не на работу CPU.

Примеры:

* Чтение/запись в базу данных.
* Загрузка данных из сети (HTTP-запросы, API).
* Работа с файлами на диске.
* Запросы к микросервисам.

**Особенности:**

* CPU большую часть времени простаивает, ожидая ответа от внешнего источника.
* Асинхронность (`async/await`) отлично работает: во время ожидания освобождается поток.
* Хорошо масштабируются — можно обрабатывать тысячи запросов на одном сервере.

Пример I/O-bound задачи:

```csharp
public async Task<string> DownloadDataAsync()
{
    using (var httpClient = new HttpClient())
    {
        string data = await httpClient.GetStringAsync("https://example.com");
        return data;
    }
}
```

Тут процессор почти не работает — он ждёт ответ от сервера.

---

### 3. Как выбрать подход?

* Если задача CPU-bound → используем **параллелизм** и оптимизацию алгоритмов.
* Если задача I/O-bound → используем **асинхронность** для освобождения потоков.
* Иногда задачи смешанные: например, загрузка данных (I/O-bound), а потом обработка этих данных (CPU-bound).

---

### 4. Для чего знать разницу?

* Чтобы правильно проектировать приложения и использовать ресурсы.
* Чтобы понимать, когда имеет смысл писать `async/await`, а когда лучше задействовать параллельные вычисления.
* Чтобы избегать блокировок потоков и увеличивать производительность.


---

### **Пример проекта**

```csharp
using System;
using System.Net.Http;
using System.Threading.Tasks;
using System.Threading;
using System.Linq;

class Program
{
    static async Task Main()
    {
        Console.WriteLine("Старт программы...");

        // Запуск I/O-bound задачи (асинхронная загрузка данных)
        Task<string> ioTask = DownloadDataAsync();

        // Параллельно запускаем CPU-bound задачу
        Task<int> cpuTask = Task.Run(() => HeavyCalculation());

        // Ожидаем оба результата
        string data = await ioTask;
        int calc = await cpuTask;

        Console.WriteLine($"\nI/O-bound результат: скачано {data.Length} символов.");
        Console.WriteLine($"CPU-bound результат: сумма вычислений = {calc}");
    }

    // I/O-bound: загрузка данных из сети
    static async Task<string> DownloadDataAsync()
    {
        Console.WriteLine("I/O-bound: Загружаю данные...");
        using (var client = new HttpClient())
        {
            // await освободит поток, пока идёт ожидание ответа
            string data = await client.GetStringAsync("https://example.com");
            Console.WriteLine("I/O-bound: Данные загружены.");
            return data;
        }
    }

    // CPU-bound: интенсивные вычисления
    static int HeavyCalculation()
    {
        Console.WriteLine("CPU-bound: Начало вычислений...");
        int sum = 0;
        for (int i = 0; i < 200_000_000; i++)
        {
            sum += i % 3;
        }
        Console.WriteLine("CPU-bound: Вычисления завершены.");
        return sum;
    }
}
```

---

### **Что происходит:**

1. **`DownloadDataAsync()`** — I/O-bound операция. Поток не блокируется, пока ждём ответ от сервера.
2. **`HeavyCalculation()`** — CPU-bound операция. Она нагружает процессор и выполняется в пуле потоков через `Task.Run()`.
3. Обе задачи выполняются параллельно, и программа ждёт обе с помощью `await`.

---

### **Главная идея**

* Асинхронность (`async/await`) нужна для I/O-bound — освобождает поток.
* Параллелизм (`Task.Run`) нужен для CPU-bound — даёт вычислениям работать в другом потоке.
